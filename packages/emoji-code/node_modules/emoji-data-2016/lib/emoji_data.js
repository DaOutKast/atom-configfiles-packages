// Generated by CoffeeScript 1.10.0
var EmojiChar, EmojiData, _str, punycode;

EmojiChar = require('./emoji_char');

punycode = require('punycode');

_str = require('underscore.string');

EmojiData = (function() {
  var EMOJICHAR_KEYWORD_MAP, EMOJICHAR_UNIFIED_MAP, EMOJI_CHARS, EMOJI_MAP, char_blob, ec, i, j, k, keyword, l, len, len1, len2, len3, ref, ref1, variant;

  function EmojiData() {}

  EMOJI_MAP = require('../vendor/emoji-data/emoji.json');

  EMOJI_CHARS = (function() {
    var i, len, results;
    results = [];
    for (i = 0, len = EMOJI_MAP.length; i < len; i++) {
      char_blob = EMOJI_MAP[i];
      results.push(new EmojiChar(char_blob));
    }
    return results;
  })();

  EMOJICHAR_UNIFIED_MAP = {};

  for (i = 0, len = EMOJI_CHARS.length; i < len; i++) {
    ec = EMOJI_CHARS[i];
    EMOJICHAR_UNIFIED_MAP[ec.unified] = ec;
    ref = ec.variations;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      variant = ref[j];
      EMOJICHAR_UNIFIED_MAP[variant] = ec;
    }
  }

  EMOJICHAR_KEYWORD_MAP = {};

  for (k = 0, len2 = EMOJI_CHARS.length; k < len2; k++) {
    ec = EMOJI_CHARS[k];
    ref1 = ec.short_names;
    for (l = 0, len3 = ref1.length; l < len3; l++) {
      keyword = ref1[l];
      EMOJICHAR_KEYWORD_MAP[keyword] = ec;
    }
  }

  EmojiData.all = function() {
    return EMOJI_CHARS;
  };

  EmojiData.all_doublebyte = function() {
    var len4, m, results;
    results = [];
    for (m = 0, len4 = EMOJI_CHARS.length; m < len4; m++) {
      ec = EMOJI_CHARS[m];
      if (ec.is_doublebyte()) {
        results.push(ec);
      }
    }
    return results;
  };

  EmojiData.all_with_variants = function() {
    var len4, m, results;
    results = [];
    for (m = 0, len4 = EMOJI_CHARS.length; m < len4; m++) {
      ec = EMOJI_CHARS[m];
      if (ec.has_variants()) {
        results.push(ec);
      }
    }
    return results;
  };

  EmojiData.chars = function(options) {
    var extra, norms;
    if (options == null) {
      options = {
        include_variants: false
      };
    }
    norms = (function() {
      var len4, m, results;
      results = [];
      for (m = 0, len4 = EMOJI_CHARS.length; m < len4; m++) {
        ec = EMOJI_CHARS[m];
        results.push(ec.render({
          variant_encoding: false
        }));
      }
      return results;
    })();
    extra = (function() {
      var len4, m, ref2, results;
      ref2 = this.all_with_variants();
      results = [];
      for (m = 0, len4 = ref2.length; m < len4; m++) {
        ec = ref2[m];
        results.push(ec.render({
          variant_encoding: true
        }));
      }
      return results;
    }).call(this);
    if (options.include_variants) {
      return norms.concat(extra);
    }
    return norms;
  };

  EmojiData.codepoints = function(options) {
    var extra, norms;
    if (options == null) {
      options = {
        include_variants: false
      };
    }
    norms = (function() {
      var len4, m, results;
      results = [];
      for (m = 0, len4 = EMOJI_CHARS.length; m < len4; m++) {
        ec = EMOJI_CHARS[m];
        results.push(ec.unified);
      }
      return results;
    })();
    extra = (function() {
      var len4, m, ref2, results;
      ref2 = this.all_with_variants();
      results = [];
      for (m = 0, len4 = ref2.length; m < len4; m++) {
        ec = ref2[m];
        results.push(ec.variant());
      }
      return results;
    }).call(this);
    if (options.include_variants) {
      return norms.concat(extra);
    }
    return norms;
  };

  EmojiData.char_to_unified = function(char) {
    var cp, cps, hexes;
    cps = punycode.ucs2.decode(char);
    hexes = (function() {
      var len4, m, results;
      results = [];
      for (m = 0, len4 = cps.length; m < len4; m++) {
        cp = cps[m];
        results.push(_str.rjust(cp.toString(16), 4, "0"));
      }
      return results;
    })();
    return hexes.join("-").toUpperCase();
  };

  EmojiData.unified_to_char = function(uid) {
    return EmojiChar._unified_to_char(uid);
  };

  EmojiData.find_by_name = function(name) {
    var len4, m, results, target;
    target = name.toUpperCase();
    results = [];
    for (m = 0, len4 = EMOJI_CHARS.length; m < len4; m++) {
      ec = EMOJI_CHARS[m];
      if (ec.name.indexOf(target) !== -1) {
        results.push(ec);
      }
    }
    return results;
  };

  EmojiData.find_by_short_name = function(short_name) {
    var len4, m, results, target;
    target = short_name.toLowerCase();
    results = [];
    for (m = 0, len4 = EMOJI_CHARS.length; m < len4; m++) {
      ec = EMOJI_CHARS[m];
      if (ec.short_names.some(function(sn) {
        return sn.indexOf(target) !== -1;
      })) {
        results.push(ec);
      }
    }
    return results;
  };

  EmojiData.from_short_name = function(short_name) {
    return EMOJICHAR_KEYWORD_MAP[short_name.toLowerCase()];
  };

  EmojiData.from_unified = function(uid) {
    return EMOJICHAR_UNIFIED_MAP[uid.toUpperCase()];
  };


  /*
   * The RegExp matcher we use to do .scan() efficiently.
   * needs to be defined after self.chars so not at top of file for now...
  FBS_REGEXP = new RegExp(
    "(?:#{EmojiData.chars({include_variants: true}).join("|")})",
    "g"
  )
  
   * Scans a string for all encoded emoji characters contained within.
   *
   * @param str [String] the target string to search
   * @return [Array<EmojiChar>] all emoji characters contained within the target
   *    string, in the order they appeared.
  @scan: (str) ->
     * since JS doesnt seem to have the equivalent of .scan we do some hacky shit
     * http://stackoverflow.com/questions/13895373/
  
     * reset regexp pointer (really js? sigh)
    FBS_REGEXP.lastIndex = 0
  
     * keep executing regex until it returns no more results
    matches = []
    while (m = FBS_REGEXP.exec(str))
      matches.push(m[0])
  
     * map matched chars to EmojiChar objects
    (@from_unified( @char_to_unified(id) ) for id in matches)
   */

  return EmojiData;

})();

module.exports = EmojiData;

module.exports.EmojiChar = EmojiChar;
